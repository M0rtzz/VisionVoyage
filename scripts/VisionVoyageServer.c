#if 0
	shc Version 4.0.3, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f VisionVoyageServer.sh -o VisionVoyageServer
#endif

static char data[] =
#define text_z 508
#define text ((&data[34]))
	"\103\005\327\330\115\310\174\020\261\227\074\367\162\112\342\277"
	"\160\255\101\146\334\302\254\346\040\153\326\041\076\034\062\201"
	"\041\011\175\205\330\023\310\304\340\124\062\204\117\141\024\000"
	"\067\114\004\051\174\301\063\253\071\124\313\350\150\112\206\242"
	"\176\171\037\025\070\216\314\006\175\053\310\336\133\375\252\006"
	"\113\335\335\311\365\317\232\166\177\111\224\004\176\043\174\017"
	"\305\155\314\033\054\073\376\020\151\216\072\366\030\111\057\127"
	"\364\202\162\367\136\236\074\163\211\107\213\142\332\040\075\375"
	"\360\243\357\111\314\331\007\372\073\353\174\052\056\007\321\241"
	"\164\225\171\235\073\355\225\305\144\130\121\134\373\041\243\300"
	"\127\355\102\024\252\034\370\306\067\220\011\315\252\045\042\031"
	"\103\173\053\201\233\261\310\103\045\114\335\050\270\271\351\126"
	"\201\003\367\047\263\215\045\351\076\362\264\266\302\104\357\340"
	"\146\035\130\006\361\221\332\073\211\275\007\267\126\002\257\144"
	"\305\077\316\352\273\306\342\343\115\373\015\120\131\264\310\221"
	"\221\166\224\104\072\274\003\050\021\134\203\226\364\375\116\002"
	"\123\044\116\122\174\130\200\371\320\364\377\150\344\330\235\002"
	"\342\115\006\377\075\333\313\130\120\334\017\204\005\346\204\020"
	"\235\152\201\370\350\255\317\323\246\353\216\035\301\160\327\156"
	"\320\002\071\273\120\012\302\327\333\033\312\017\100\036\174\147"
	"\141\037\252\270\366\332\237\015\361\313\314\060\244\133\325\030"
	"\002\317\041\376\010\077\045\361\060\345\252\163\042\132\356\135"
	"\020\340\122\163\025\215\241\322\022\035\237\055\202\355\113\102"
	"\234\034\377\262\160\237\014\177\365\173\336\332\312\324\270\251"
	"\315\050\163\271\346\231\100\316\151\310\153\010\273\363\050\260"
	"\175\073\025\046\356\313\271\060\346\136\020\345\377\317\073\301"
	"\062\145\267\310\030\000\243\055\107\065\016\346\333\041\163\000"
	"\302\322\272\334\364\334\153\311\150\037\106\000\355\124\012\326"
	"\201\032\011\113\075\005\357\306\012\263\244\174\027\015\011\200"
	"\003\367\014\333\274\267\270\037\322\137\244\012\332\071\127\077"
	"\306\072\231\335\006\025\307\373\130\104\246\242\104\076\217\006"
	"\317\077\263\311\135\337\316\224\077\116\173\267\230\301\004\027"
	"\141\041\200\127\033\072\002\141\227\143\235\121\020\263\065\154"
	"\073\310\226\140\277\336\245\103\361\061\303\020\075\173\131\157"
	"\322\325\200\204\155\274"
#define tst1_z 22
#define tst1 ((&data[555]))
	"\136\237\170\014\340\063\321\061\034\042\241\136\147\325\234\072"
	"\371\372\315\320\276\223\300\176\374\203\104"
#define tst2_z 19
#define tst2 ((&data[581]))
	"\212\317\303\365\172\132\260\265\342\230\135\223\141\223\037\245"
	"\036\035\205\366\335\330\000\245\344\064"
#define opts_z 1
#define opts ((&data[603]))
	"\077"
#define chk2_z 19
#define chk2 ((&data[604]))
	"\023\151\370\210\157\202\123\147\275\152\130\342\132\142\340\224"
	"\145\216\202"
#define inlo_z 3
#define inlo ((&data[623]))
	"\357\143\344"
#define pswd_z 256
#define pswd ((&data[656]))
	"\220\362\063\230\120\322\020\134\262\357\105\125\172\024\030\160"
	"\272\375\244\173\024\131\137\065\151\262\050\116\205\237\140\266"
	"\012\141\037\127\105\136\005\012\265\361\203\005\212\042\117\125"
	"\377\344\343\363\255\277\275\206\200\044\234\253\327\375\142\341"
	"\136\202\071\243\340\076\256\226\060\061\234\272\123\354\020\123"
	"\320\364\107\175\263\004\003\064\050\240\340\000\235\102\342\373"
	"\304\033\237\245\131\115\073\211\176\327\104\322\304\125\046\224"
	"\112\155\021\375\161\025\062\232\266\022\232\123\124\174\117\031"
	"\227\357\276\361\075\371\173\274\321\300\216\225\025\264\051\137"
	"\042\073\135\223\121\217\056\010\242\310\133\366\105\253\017\335"
	"\232\316\316\327\310\112\223\231\012\042\057\037\327\131\177\371"
	"\225\335\214\346\155\272\356\017\203\112\006\310\365\026\246\217"
	"\344\164\147\254\277\372\105\311\034\165\351\363\316\151\355\143"
	"\106\171\112\263\064\071\303\270\203\311\201\171\337\047\011\303"
	"\234\160\157\133\152\265\045\207\052\016\173\370\167\150\133\276"
	"\342\246\162\027\337\065\317\143\376\120\334\335\170\345\241\024"
	"\125\020\160\300\306\225\107\360\243\303\351\033\053\105\332\016"
	"\353\114\045\313\202\365\056\200\106\012\136\276\357\000\242\025"
	"\221\325\256\342\247\276\077\132\255\204\257\047\230\310\230\122"
	"\306\074\316"
#define msg1_z 65
#define msg1 ((&data[942]))
	"\020\377\337\070\116\145\327\360\173\175\223\273\220\212\314\072"
	"\201\353\336\122\311\231\245\004\167\245\111\272\360\131\117\211"
	"\256\277\034\136\322\204\127\172\312\205\034\272\165\061\017\015"
	"\272\015\367\360\307\370\366\206\334\307\150\313\050\155\241\141"
	"\260\044\215\065\322\116\016\206\056\166\150\305\051"
#define xecc_z 15
#define xecc ((&data[1011]))
	"\212\373\237\221\204\041\033\071\362\073\345\331\200\232\222\336"
	"\310\226\016"
#define chk1_z 22
#define chk1 ((&data[1033]))
	"\100\126\372\007\032\026\101\022\104\062\330\223\025\354\130\026"
	"\202\150\163\207\312\251\064\206\307\017\222\311\342"
#define date_z 1
#define date ((&data[1058]))
	"\351"
#define shll_z 14
#define shll ((&data[1062]))
	"\166\074\002\375\233\342\361\114\241\225\310\310\317\265\033\365"
	"\215"
#define lsto_z 1
#define lsto ((&data[1076]))
	"\261"
#define msg2_z 19
#define msg2 ((&data[1081]))
	"\232\311\100\143\216\212\027\172\327\270\307\067\121\366\021\266"
	"\351\354\030\274\160\072\132\137\116\333"
#define rlax_z 1
#define rlax ((&data[1103]))
	"\344" /* End of data[] */;
#define hide_z 4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC 0 /* Define as 1 to debug execvp calls */
#define TRACEABLE 1 /* Define as 1 to enable ptrace the executable */
#define HARDENING 0 /* Define as 1 to disable ptrace/dump the executable */
#define BUSYBOXON 0 /* Define as 1 to enable work with busybox */

#if HARDENING
static const char *shc_x[] = {
	"/*",
	" * Copyright 2019 - Intika <intika@librefox.org>",
	" * Replace ******** with secret read from fd 21",
	" * Also change arguments location of sub commands (sh script commands)",
	" * gcc -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl",
	" */",
	"",
	"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */",
	"#define PLACEHOLDER \"********\"",
	"#include <dlfcn.h>",
	"#include <stdlib.h>",
	"#include <string.h>",
	"#include <unistd.h>",
	"#include <stdio.h>",
	"#include <signal.h>",
	"",
	"static char secret[128000]; //max size",
	"typedef int (*pfi)(int, char **, char **);",
	"static pfi real_main;",
	"",
	"// copy argv to new location",
	"char **copyargs(int argc, char** argv){",
	"    char **newargv = malloc((argc+1)*sizeof(*argv));",
	"    char *from,*to;",
	"    int i,len;",
	"",
	"    for(i = 0; i<argc; i++){",
	"        from = argv[i];",
	"        len = strlen(from)+1;",
	"        to = malloc(len);",
	"        memcpy(to,from,len);",
	"        // zap old argv space",
	"        memset(from,'\\0',len);",
	"        newargv[i] = to;",
	"        argv[i] = 0;",
	"    }",
	"    newargv[argc] = 0;",
	"    return newargv;",
	"}",
	"",
	"static int mymain(int argc, char** argv, char** env) {",
	"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
	"    return real_main(argc, copyargs(argc,argv), env);",
	"}",
	"",
	"int __libc_start_main(int (*main) (int, char**, char**),",
	"                      int argc,",
	"                      char **argv,",
	"                      void (*init) (void),",
	"                      void (*fini)(void),",
	"                      void (*rtld_fini)(void),",
	"                      void (*stack_end)){",
	"    static int (*real___libc_start_main)() = NULL;",
	"    int n;",
	"",
	"    if (!real___libc_start_main) {",
	"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
	"        if (!real___libc_start_main) abort();",
	"    }",
	"",
	"    n = read(21, secret, sizeof(secret));",
	"    if (n > 0) {",
	"      int i;",
	"",
	"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
	"    for (i = 1; i < argc; i++)",
	"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
	"          argv[i] = secret;",
	"    }",
	"",
	"    real_main = main;",
	"",
	"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
	"}",
	"",
	0};
#endif /* HARDENING */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte.
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do
	{
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once.
 */
void key(void *str, int len)
{
	unsigned char tmp, *ptr = (unsigned char *)str;
	while (len > 0)
	{
		do
		{
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data.
 */
void arc4(void *str, int len)
{
	unsigned char tmp, *ptr = (unsigned char *)str;
	while (len > 0)
	{
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall)                                        \
	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, SYS_##syscall, 0, 1), \
		BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
	/* validate arch */
	BPF_STMT(BPF_LD + BPF_W + BPF_ABS, ArchField),
	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, AUDIT_ARCH_X86_64, 1, 0),
	BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),

	/* load syscall */
	BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(struct seccomp_data, nr)),

	/* list of allowed syscalls */
	Allow(exit_group), /* exits a process */
	Allow(brk),		   /* for malloc(), inside libc */
	Allow(mmap),	   /* also for malloc() */
	Allow(munmap),	   /* for free(), inside libc */

	/* and if we don't match above, die */
	BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
	.len = sizeof(filter) / sizeof(filter[0]),
	.filter = filter};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening()
{
	if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0))
	{
		perror("Could not start seccomp:");
		exit(1);
	}
	if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1)
	{
		perror("Could not start seccomp:");
		exit(1);
	}
}
/* End Seccomp Sandboxing Init */

void shc_x_file()
{
	FILE *fp;
	int line = 0;

	if ((fp = fopen("/tmp/shc_x.c", "w")) == NULL)
	{
		exit(1);
		exit(1);
	}
	for (line = 0; shc_x[line]; line++)
		fprintf(fp, "%s\n", shc_x[line]);
	fflush(fp);
	fclose(fp);
}

int make()
{
	char *cc, *cflags, *ldflags;
	char cmd[4096];

	cc = getenv("CC");
	if (!cc)
		cc = "cc";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/tmp/shc_x.so", "/tmp/shc_x.c -ldl");
	if (system(cmd))
	{
		remove("/tmp/shc_x.c");
		return -1;
	}
	remove("/tmp/shc_x.c");
	return 0;
}

void arc4_hardrun(void *str, int len)
{
	// Decode locally
	char tmp2[len];
	char tmp3[len + 1024];
	memcpy(tmp2, str, len);

	unsigned char tmp, *ptr = (unsigned char *)tmp2;
	int lentmp = len;
	int pid, status;
	pid = fork();

	shc_x_file();
	if (make())
	{
		exit(1);
	}

	setenv("LD_PRELOAD", "/tmp/shc_x.so", 1);

	if (pid == 0)
	{

		// Start tracing to protect from dump & trace
		if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0)
		{
			kill(getpid(), SIGKILL);
			_exit(1);
		}

		// Decode Bash
		while (len > 0)
		{
			indx++;
			tmp = stte[indx];
			jndx += tmp;
			stte[indx] = stte[jndx];
			stte[jndx] = tmp;
			tmp += stte[indx];
			*ptr ^= stte[tmp];
			ptr++;
			len--;
		}

		// Do the magic
		sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

		// Exec bash script //fork execl with 'sh -c'
		system(tmp2);

		// Empty script variable
		memcpy(tmp2, str, lentmp);

		// Clean temp
		remove("/tmp/shc_x.so");

		// Sinal to detach ptrace
		ptrace(PTRACE_DETACH, 0, 0, 0);
		exit(0);
	}
	else
	{
		wait(&status);
	}

	/* Seccomp Sandboxing - Start */
	seccomp_hardening();

	exit(0);
}
#endif /* HARDENING */

/*
 * Key with file invariants.
 */
int key_with_file(char *file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char *sh11, int argc, char **argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv)
	{
		fprintf(stderr, "argv=<null>\n");
	}
	else
	{
		for (i = 0; i <= argc; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char **argv, char *arg)
{
	for (; argv && *argv && *argv != arg; argv++)
		;
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char *string;
	extern char **environ;

	mask = (unsigned long)getpid();
	stte_0();
	key(&chkenv, (void *)&chkenv_end - (void *)&chkenv);
	key(&data, sizeof(data));
	key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string)
	{
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask)
	{
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void) {}

#if HARDENING

static void gets_process_name(const pid_t pid, char *name)
{
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE *f = fopen(procfile, "r");
	if (f)
	{
		size_t size;
		size = fread(name, sizeof(char), sizeof(procfile), f);
		if (size > 0)
		{
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening()
{
	prctl(PR_SET_DUMPABLE, 0);
	prctl(PR_SET_PTRACER, -1);

	int pid = getppid();
	char name[256] = {0};
	gets_process_name(pid, name);

	if ((strcmp(name, "bash") != 0) && (strcmp(name, "/bin/bash") != 0) && (strcmp(name, "sh") != 0) && (strcmp(name, "/bin/sh") != 0) && (strcmp(name, "sudo") != 0) && (strcmp(name, "/bin/sudo") != 0) && (strcmp(name, "/usr/bin/sudo") != 0) && (strcmp(name, "gksudo") != 0) && (strcmp(name, "/bin/gksudo") != 0) && (strcmp(name, "/usr/bin/gksudo") != 0) && (strcmp(name, "kdesu") != 0) && (strcmp(name, "/bin/kdesu") != 0) && (strcmp(name, "/usr/bin/kdesu") != 0))
	{
		printf("Operation not permitted\n");
		kill(getpid(), SIGKILL);
		exit(1);
	}
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#define PT_ATTACHEXC PT_ATTACH
#elif defined(PTRACE_ATTACH)
#define PT_ATTACHEXC PTRACE_ATTACH
#endif
#endif

void untraceable(char *argv0)
{
	char proc[80];
	int pid, mine;

	switch (pid = fork())
	{
	case 0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as", (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR | O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine)
		{
			kill(pid, SIGCONT);
		}
		else
		{
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char *xsh(int argc, char **argv)
{
	char *scrpt;
	int ret, i, j;
	char **varg;
	char *me = argv[0];
	if (me == NULL)
	{
		me = getenv("_");
	}
	if (me == 0)
	{
		fprintf(stderr, "E: neither argv[0] nor $_ works.");
		exit(1);
	}

	ret = chkenv(argc);
	stte_0();
	key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date) < time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret)
	{
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
		arc4_hardrun(text, text_z);
		exit(0);
		/* Seccomp Sandboxing - Start */
		seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int)' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	}
	else
	{ /* Reexecute */
		if (*xecc)
		{
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		}
		else
		{
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0]; /* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts; /* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo; /* Option introducing inline code */
	varg[j++] = scrpt;	  /* The script itself */
	if (*lsto)
		varg[j++] = lsto;	 /* Option meaning last option */
	i = (ret > 1) ? ret : 0; /* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++]; /* Main run-time arguments */
	varg[j] = 0;			   /* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char **argv)
{
#if SETUID
	setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
			errno ? ": " : "",
			errno ? strerror(errno) : "",
			argv[1] ? argv[1] : "<null>");
	return 1;
}
